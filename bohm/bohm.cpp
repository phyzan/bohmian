#include <odepack/pyode.hpp>
#include <mpreal.h>

using mpfr::mpreal;
using Tt = double;
using Ty = vec<Tt, 4>;
using Args = std::vector<Tt>;
static const Tt ONE = Tt(1);
static const Tt TWO = Tt(2);
static const Tt HALF = ONE/TWO;
static const Tt SQRT2 = pow(TWO, HALF);



Ty f(const Tt& t, const Ty& q, const Args& args){
	return {std::imag(exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0])*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) - exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t))*args[2])/(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2])), imag(exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(-exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1])*args[2])/(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2])), imag(-(exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(-exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0], TWO)*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*args[0]*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) - exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*pow(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t), TWO)*args[2] + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[0]*args[2])/(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2]) + exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*pow(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0])*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) - exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t))*args[2], TWO)/pow(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2], TWO)))*q[2] + imag(-(exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0])*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1])*(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t))*args[2])/(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2]) + exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0])*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) - exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t))*args[2])*(-exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1])*args[2])/pow(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2], TWO)))*q[3], imag(-(exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0])*(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1])*args[2])/(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2]) + exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(-exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1])*args[2])*(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t) + pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] - q[0]*args[0])*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) - exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*cos(args[0]*t)*args[3] + q[0]*args[0] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t))*args[2])/pow(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2], TWO)))*q[2] + imag(-(exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*(-exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t), TWO)*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*args[1]*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) - exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*pow(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1], TWO)*args[2] + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[1]*args[2])/(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2]) + exp(std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO) - (std::complex<Tt>(0, 1)*cos(args[0]*t)*sin(args[0]*t)*pow(args[3], TWO) + std::complex<Tt>(0, 1)*cos(args[1]*t)*sin(args[1]*t)*pow(args[3], TWO) - std::complex<Tt>(0, HALF)*t*(args[0] + args[1]) + TWO*pow(args[3], TWO)))*pow(-exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*(pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] + q[1]*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*(std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t) + pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*cos(args[1]*t)*args[3] - q[1]*args[1])*args[2], TWO)/pow(exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0] - pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] + pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1]))*pow(ONE - pow(abs(args[2]), TWO), ONE/TWO) + exp(-(-std::complex<Tt>(0, -1)*pow(TWO, ONE/TWO)*pow(args[1], ONE/TWO)*args[3]*sin(args[1]*t)*q[1] + pow(args[0], ONE/TWO)*cos(args[0]*t)*pow(TWO, ONE/TWO)*args[3]*q[0] + pow(cos(args[0]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[0], TWO)*args[0] - pow(args[1], ONE/TWO)*cos(args[1]*t)*pow(TWO, ONE/TWO)*args[3]*q[1] + pow(cos(args[1]*t), TWO)*pow(args[3], TWO) + ONE/TWO*pow(q[1], TWO)*args[1] - std::complex<Tt>(0, 1)*pow(TWO, ONE/TWO)*pow(args[0], ONE/TWO)*args[3]*sin(args[0]*t)*q[0]))*args[2], TWO)))*q[3]};
}


Ty renormalize(const Tt& t, const Ty& y, const std::vector<Tt>& args){
	Tt norm = pow(y[2]*y[2] + y[3]*y[3], HALF);
	return {y[0], y[1], y[2]/norm, y[3]/norm};
}

// std::vector<Tt> checkpoints(const Tt every, const Tt interval, const Tt start=0){
// 	std::vector<Tt> res;
// 	Tt t = start;
// 	while (t <= interval){
// 		t += every;
// 		res.push_back(t);
// 	}
// 	return res;
// }


// int main(){

// 	mpreal::set_default_prec(100); // Correct way

// 	Event<Tt, Ty> ev("Renormalize", checkpoints(0.1, 100000), nullptr, renormalize);

// 	ODE<Tt, Ty> ode(f, 0, {-1, 1, 1/SQRT2, 1/SQRT2}, pow(Tt(10), -4), 0, pow(Tt(10), Tt(-12)), 0, {1, 1/SQRT2, 1/SQRT2, 5/TWO}, "RK45", pow(10, Tt(-10)), {ev});

// 	ode.integrate(1, 10000, -1, true, true).examine();

// 	ode.state().show();

// 	// ode.integrate()
// }

// omega1 = 1
// omega2 = 1/2**0.5
// c2 = 1/2**0.5
// a0 = 5/2




// g++ -O3 -Wall -std=c++20 -fopenmp -fPIC -fno-math-errno bohm.cpp -o bohm -lmpfr -lgmp



std::vector<Tt> parse_events(py::object checkpoints, Tt d=0){
	std::vector<Tt> res;
	for (const py::handle& t : checkpoints){
		Tt _t = t.cast<Tt>();
		res.push_back(_t-d);
	}
	return res;
}


Tt stopevent(const Tt& t, const Ty& y, const std::vector<Tt>& args){
	Tt norm = pow(y[2]*y[2] + y[3]*y[3], HALF);
	return norm-10.;
}


#pragma GCC visibility push(hidden)
class BohmianOrbit : public PyODE<Tt, Ty> {

    public:
		BohmianOrbit(const Tt& t0, const py::array q0, const py::tuple args, const Tt stepsize, const Tt rtol, const Tt atol, const Tt min_step, py::object checkpoints):PyODE<Tt, Ty>(f, t0, toCPP_Array<Tt, Ty>(q0), stepsize, rtol, atol, min_step, toCPP_Array<Tt, std::vector<Tt>>(args), "RK45", 0., {Event<Tt, Ty>("Renormalization", parse_events(checkpoints), nullptr, renormalize), Event<Tt, Ty>("Checkpoint", parse_events(checkpoints, 1e-13))}, {}){}
};
#pragma GCC visibility pop

PYBIND11_MODULE(bohm, m){
	define_ode_module<Tt, vec<Tt, 4>>(m);

	py::class_<BohmianOrbit, PyODE<Tt, Ty>>(m, "BohmianOrbit", py::module_local())
	.def(py::init<Tt, py::array, py::tuple, Tt, Tt, Tt, Tt, py::object>(),
		py::arg("t0"),
		py::arg("q0"),
		py::arg("args"),
		py::arg("stepsize"),
		py::kw_only(),
		py::arg("rtol")=1e-6,
		py::arg("atol")=1e-12,
		py::arg("min_step")=0.,
		py::arg("checkpoints")=py::make_tuple())
			
	.def_property_readonly("events", [](const BohmianOrbit& self){return to_numpy<size_t>(self.ode.event_map().at("Renormalization"),{});});
}
